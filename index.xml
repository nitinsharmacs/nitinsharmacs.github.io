<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
    <channel>
      <title>bitPhile</title>
      <link>https://nitinsharmacs.github.io</link>
      <description>Last 10 notes on bitPhile</description>
      <generator>Quartz -- quartz.jzhao.xyz</generator>
      <item>
    <title>setup-ssh-with-gitlab</title>
    <link>https://nitinsharmacs.github.io/notes/tech/git/setup-ssh-with-gitlab</link>
    <guid>https://nitinsharmacs.github.io/notes/tech/git/setup-ssh-with-gitlab</guid>
    <description>Setup ssh with gitlab Step 1: Generate ssh key pair ssh-keygen -t rsa -b 2048 -C &quot;nitinsharmacs@gitlab.com&quot; -t can be any encryption you want to use ...</description>
    <pubDate>Fri, 27 Sep 2024 06:28:42 GMT</pubDate>
  </item><item>
    <title>gitlab-ci</title>
    <link>https://nitinsharmacs.github.io/notes/tech/git/gitlab-ci</link>
    <guid>https://nitinsharmacs.github.io/notes/tech/git/gitlab-ci</guid>
    <description>Gitlab CI A gitlab ci contains stages and job. Jobs are grouped in stages and run in parallel. stages: - build - deploy build-job: stage: build image: node script: - npm install - npm run build artifacts: paths: - &quot;build/&quot; pages: stage: deploy script: - mv build/ public/ artifacts: paths: - &quot;public/&quot; stages directive defines the sequence of jobs.</description>
    <pubDate>Fri, 27 Sep 2024 06:28:42 GMT</pubDate>
  </item><item>
    <title>apply_ufunc-dask</title>
    <link>https://nitinsharmacs.github.io/notes/tech/xarray/apply_ufunc-dask</link>
    <guid>https://nitinsharmacs.github.io/notes/tech/xarray/apply_ufunc-dask</guid>
    <description>apply_ufunc with dask arrays apply_ufunc handles dask xarray in same manner as it does with numpy xarray. However, it requires an dask argument` to work with dask xarrays.</description>
    <pubDate>Fri, 27 Sep 2024 06:28:42 GMT</pubDate>
  </item><item>
    <title>map_blocks</title>
    <link>https://nitinsharmacs.github.io/notes/tech/xarray/map_blocks</link>
    <guid>https://nitinsharmacs.github.io/notes/tech/xarray/map_blocks</guid>
    <description>xarray.map_blocks It applies custom function on each chunk block of the DataArray or Dataset. def add_wrapper(d): print(&#039;------------------- START ---------------------&#039;) print(type(d)) print(d.shape) print(d) print(&#039;-------------------- END ------------------------&#039;) return d + 1 xda = ds.air[:2, :5, :5].chunk({&quot;time&quot;: 1}) xr.map_blocks(add_wrapper, ds.air).compute() Output ------------------- START --------------------- &lt;class &#039;xarray.core.dataarray.DataArray&#039;&gt; (0, 0, 0) &lt;xarray.DataArray &#039;air&#039; (time: 0, lat: 0, lon: 0)&gt; Size: 0B array([], shape=(0, 0, 0), dtype=float64) -------------------- END ------------------------ ------------------- START --------------------- &lt;class &#039;xarray.core.dataarray.DataArray&#039;&gt; (1, 5, 5) &lt;xarray.DataArray &#039;air&#039; (time: 1, lat: 5, lon: 5)&gt; Size: 200B array([[[241.2 , 242.5 , 243.5 , 244.</description>
    <pubDate>Fri, 27 Sep 2024 06:28:42 GMT</pubDate>
  </item><item>
    <title>apply_ufunc</title>
    <link>https://nitinsharmacs.github.io/notes/tech/xarray/apply_ufunc</link>
    <guid>https://nitinsharmacs.github.io/notes/tech/xarray/apply_ufunc</guid>
    <description>apply_ufunc Xarray method that applies custom function on underlying array in xarray. The underlying array can be a numpy or a dask array (need verification).</description>
    <pubDate>Fri, 27 Sep 2024 06:28:42 GMT</pubDate>
  </item><item>
    <title>loop-dimensions</title>
    <link>https://nitinsharmacs.github.io/notes/tech/xarray/loop-dimensions</link>
    <guid>https://nitinsharmacs.github.io/notes/tech/xarray/loop-dimensions</guid>
    <description>Loop Dimensions Functions that performs operations on data with core-dimensions and taking axis as argument, can be easily used with apply_ufunc. However, functions which donâ€™t take axis argument and need to work on core-dimensions need loop dimensions.</description>
    <pubDate>Fri, 27 Sep 2024 06:28:42 GMT</pubDate>
  </item><item>
    <title>xarray-with-dask</title>
    <link>https://nitinsharmacs.github.io/notes/tech/xarray/xarray-with-dask</link>
    <guid>https://nitinsharmacs.github.io/notes/tech/xarray/xarray-with-dask</guid>
    <description>Xarray with Dask Xarray is numpy array with metadata and accessing the array with metadata. Xarray does the computations in memory so has the limitation on data size.</description>
    <pubDate>Fri, 27 Sep 2024 06:28:42 GMT</pubDate>
  </item><item>
    <title>core-dimensions</title>
    <link>https://nitinsharmacs.github.io/notes/tech/xarray/core-dimensions</link>
    <guid>https://nitinsharmacs.github.io/notes/tech/xarray/core-dimensions</guid>
    <description>Core Dimensions Fundamental dimensions over which an operation is defined. Why core dimensions? apply_ufunc is used to create generalized operations on xarray data.</description>
    <pubDate>Fri, 27 Sep 2024 06:28:42 GMT</pubDate>
  </item><item>
    <title>xarray-so-far</title>
    <link>https://nitinsharmacs.github.io/notes/tech/xarray/xarray-so-far</link>
    <guid>https://nitinsharmacs.github.io/notes/tech/xarray/xarray-so-far</guid>
    <description> xarray is made on top of numpy by adding more information about the nature of data. adding lables to the dimensions. Instead of just raw dimension, xarray added name to them such as time, longitude, etc.</description>
    <pubDate>Fri, 27 Sep 2024 06:28:42 GMT</pubDate>
  </item><item>
    <title>apply_ufunc-dask-vectorize</title>
    <link>https://nitinsharmacs.github.io/notes/tech/xarray/apply_ufunc-dask-vectorize</link>
    <guid>https://nitinsharmacs.github.io/notes/tech/xarray/apply_ufunc-dask-vectorize</guid>
    <description>Vectorize Dask Xarray Vectorization for dask xarray works only when we give dask=parallelized parameter. From the note we saw that dask.array.apply_gufunc provides chunk blocks to custom function.</description>
    <pubDate>Fri, 27 Sep 2024 06:28:42 GMT</pubDate>
  </item>
    </channel>
  </rss>