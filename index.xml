<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
    <channel>
      <title>bitPhile</title>
      <link>https://nitinsharmacs.github.io</link>
      <description>Last 10 notes on bitPhile</description>
      <generator>Quartz -- quartz.jzhao.xyz</generator>
      <item>
    <title>polyfit</title>
    <link>https://nitinsharmacs.github.io/notes/tech/numpy/notebook/polyfit</link>
    <guid>https://nitinsharmacs.github.io/notes/tech/numpy/notebook/polyfit</guid>
    <description>import numpy as np import matplotlib.pyplot as plt polyfit Objective is to create a fit of a set of data points and plot it. 1 degree polynomial x = np.array([1, 2, 3, 4]) y = np.array([1, 2, 3, 4]) fit = np.polyfit(x, y, 1) equation = np.poly1d(fit) x_points = np.linspace(1, 10, 100) y_points = equation(x_points) plt.figure(figsize=(4, 2)) plt.plot(x, y, &#039;.&#039;) plt.plot(x_points, y_points, &#039;-r&#039;) [&lt;matplotlib.lines.Line2D at 0x14c8564d0&gt;] 2 degree polynomial degree_2_fit = np.polyfit(x, y, 2) degree_2_eq = np.poly1d(degree_2_fit) print(degree_2_eq) 2 -4.958e-16 x + 1 x - 2.442e-15 y_points = degree_2_eq(x_points) plt.figure(figsize=(4, 2)) plt.plot(x, y, &#039;.&#039;, x_points, y_points, &#039;-r&#039;) [&lt;matplotlib.lines.Line2D at 0x14c7af670&gt;, &lt;matplotlib.lines.Line2D at 0x14c7afcd0&gt;] .</description>
    <pubDate>Thu, 03 Oct 2024 12:40:38 GMT</pubDate>
  </item><item>
    <title>numpy.polynomials</title>
    <link>https://nitinsharmacs.github.io/notes/tech/numpy/notebook/numpy.polynomials</link>
    <guid>https://nitinsharmacs.github.io/notes/tech/numpy/notebook/numpy.polynomials</guid>
    <description>Goal Understanding polynomials handling methods of numpy. Includes poly1d polyval polyfit import numpy as np poly1d Creates a polynomial Creating polynomial # Creating polynomial of order 1 # 2x + 1 pol = np.poly1d([2, 1]) print(pol) 2 x + 1 # Creating a polynomal of order 2 # 2x^2 + 3x + 4 pol = np.poly1d([2, 3, 4]) print(pol) 2 2 x + 3 x + 4 Evaluation # Evaluating pol with x = 2 print(pol) print(pol(2)) print(pol([2, 3, 4])) 2 2 x + 3 x + 4 18 [18 31 48] Arithmetic operations # addition of pols print(pol + pol) # multiplication print(pol * pol) # division print(pol / pol) # returns quotient and remainder # square pols print(pol ** 3) 2 4 x + 6 x + 8 4 3 2 4 x + 12 x + 25 x + 24 x + 16 (poly1d([1.]), poly1d([0.])) 6 5 4 3 2 8 x + 36 x + 102 x + 171 x + 204 x + 144 x + 64 polyval np.polynomial.polynomial.polyval([1,2,3, 4], [2, 3, 4]) array([ 9., 24., 47., 78.]) print(pol(4)) 48 Issue? print(pol) print(pol(2)) print(np.polynomial.polynomial.polyval(2, pol)) # why both evaluations result different values? 2 2 x + 3 x + 4 18 24.0 polyfit polyfit is used to find the cofficient of a polynomial that best fits the given data points.</description>
    <pubDate>Thu, 03 Oct 2024 12:40:38 GMT</pubDate>
  </item><item>
    <title>interoperability</title>
    <link>https://nitinsharmacs.github.io/notes/tech/numpy/interoperability</link>
    <guid>https://nitinsharmacs.github.io/notes/tech/numpy/interoperability</guid>
    <description>Interoperability Interoperability defines how well numpy integrates with other libraries. To accomplish this, there are solutions like old buffer protocol and array interface.</description>
    <pubDate>Mon, 30 Sep 2024 17:44:37 GMT</pubDate>
  </item><item>
    <title>export</title>
    <link>https://nitinsharmacs.github.io/notes/tech/conda/export</link>
    <guid>https://nitinsharmacs.github.io/notes/tech/conda/export</guid>
    <description>Conda export Exporting all the dependencies and their additional packages. conda env export &gt; file.yml # or conda export -n env &gt; file.yml This make sense when environment is being created in same platform as the source.</description>
    <pubDate>Sun, 29 Sep 2024 07:40:41 GMT</pubDate>
  </item><item>
    <title>strides</title>
    <link>https://nitinsharmacs.github.io/notes/tech/numpy/strides</link>
    <guid>https://nitinsharmacs.github.io/notes/tech/numpy/strides</guid>
    <description>Strides array.strides gives the number of bytes need to be jumped to find the next elements on the corresponding dimensions. a = np.arange(4).reshape((2, 2)) # array([[0, 1], # [2, 3]]) a.strides # (16, 8) So, 16 bytes for x-axis and 8 bytes for y-axis needs to be jumped to get to next element.</description>
    <pubDate>Fri, 27 Sep 2024 09:04:45 GMT</pubDate>
  </item><item>
    <title>setup-ssh-with-gitlab</title>
    <link>https://nitinsharmacs.github.io/notes/tech/git/setup-ssh-with-gitlab</link>
    <guid>https://nitinsharmacs.github.io/notes/tech/git/setup-ssh-with-gitlab</guid>
    <description>Setup ssh with gitlab Step 1: Generate ssh key pair ssh-keygen -t rsa -b 2048 -C &quot;nitinsharmacs@gitlab.com&quot; -t can be any encryption you want to use ...</description>
    <pubDate>Fri, 27 Sep 2024 06:28:42 GMT</pubDate>
  </item><item>
    <title>gitlab-ci</title>
    <link>https://nitinsharmacs.github.io/notes/tech/git/gitlab-ci</link>
    <guid>https://nitinsharmacs.github.io/notes/tech/git/gitlab-ci</guid>
    <description>Gitlab CI A gitlab ci contains stages and job. Jobs are grouped in stages and run in parallel. stages: - build - deploy build-job: stage: build image: node script: - npm install - npm run build artifacts: paths: - &quot;build/&quot; pages: stage: deploy script: - mv build/ public/ artifacts: paths: - &quot;public/&quot; stages directive defines the sequence of jobs.</description>
    <pubDate>Fri, 27 Sep 2024 06:28:42 GMT</pubDate>
  </item><item>
    <title>apply_ufunc-dask</title>
    <link>https://nitinsharmacs.github.io/notes/tech/xarray/apply_ufunc-dask</link>
    <guid>https://nitinsharmacs.github.io/notes/tech/xarray/apply_ufunc-dask</guid>
    <description>apply_ufunc with dask arrays apply_ufunc handles dask xarray in same manner as it does with numpy xarray. However, it requires an dask argument` to work with dask xarrays.</description>
    <pubDate>Fri, 27 Sep 2024 06:28:42 GMT</pubDate>
  </item><item>
    <title>map_blocks</title>
    <link>https://nitinsharmacs.github.io/notes/tech/xarray/map_blocks</link>
    <guid>https://nitinsharmacs.github.io/notes/tech/xarray/map_blocks</guid>
    <description>xarray.map_blocks It applies custom function on each chunk block of the DataArray or Dataset. def add_wrapper(d): print(&#039;------------------- START ---------------------&#039;) print(type(d)) print(d.shape) print(d) print(&#039;-------------------- END ------------------------&#039;) return d + 1 xda = ds.air[:2, :5, :5].chunk({&quot;time&quot;: 1}) xr.map_blocks(add_wrapper, ds.air).compute() Output ------------------- START --------------------- &lt;class &#039;xarray.core.dataarray.DataArray&#039;&gt; (0, 0, 0) &lt;xarray.DataArray &#039;air&#039; (time: 0, lat: 0, lon: 0)&gt; Size: 0B array([], shape=(0, 0, 0), dtype=float64) -------------------- END ------------------------ ------------------- START --------------------- &lt;class &#039;xarray.core.dataarray.DataArray&#039;&gt; (1, 5, 5) &lt;xarray.DataArray &#039;air&#039; (time: 1, lat: 5, lon: 5)&gt; Size: 200B array([[[241.2 , 242.5 , 243.5 , 244.</description>
    <pubDate>Fri, 27 Sep 2024 06:28:42 GMT</pubDate>
  </item><item>
    <title>apply_ufunc</title>
    <link>https://nitinsharmacs.github.io/notes/tech/xarray/apply_ufunc</link>
    <guid>https://nitinsharmacs.github.io/notes/tech/xarray/apply_ufunc</guid>
    <description>apply_ufunc Xarray method that applies custom function on underlying array in xarray. The underlying array can be a numpy or a dask array (need verification).</description>
    <pubDate>Fri, 27 Sep 2024 06:28:42 GMT</pubDate>
  </item>
    </channel>
  </rss>