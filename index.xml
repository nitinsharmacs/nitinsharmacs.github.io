<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
    <channel>
      <title>bitPhile</title>
      <link>https://nitinsharmacs.github.io</link>
      <description>Last 10 notes on bitPhile</description>
      <generator>Quartz -- quartz.jzhao.xyz</generator>
      <item>
    <title>masked-arrays</title>
    <link>https://nitinsharmacs.github.io/notes/tech/numpy/masked-arrays</link>
    <guid>https://nitinsharmacs.github.io/notes/tech/numpy/masked-arrays</guid>
    <description>Masked Arrays Masked arrays are arrays with invalid or missing values. Numpy has numpy.ma module dedicated to masked arrays. np.ma.array([1, 2, 3, 4], mask=[0, 1, 0, 1]) # masked_array(data=[1, --, 3, --], # mask=[False, True, False, True], # fill_value=999999) References lectures.scientific-python.org/intro/numpy/elaborate_arrays.html#maskedarray-dealing-with-propagation-of-missing-data .</description>
    <pubDate>Thu, 19 Sep 2024 15:49:47 GMT</pubDate>
  </item><item>
    <title>datatype-sizes</title>
    <link>https://nitinsharmacs.github.io/notes/tech/numpy/datatype-sizes</link>
    <guid>https://nitinsharmacs.github.io/notes/tech/numpy/datatype-sizes</guid>
    <description>Datatype sizes Integers int8 int16 int32 (int for 32bits) int64 (int for 64bits) uint8 uint16 uint32 uint64 np.array([2**32], dtype=np.int32).dtype # shows deprecation warning ...</description>
    <pubDate>Thu, 19 Sep 2024 15:06:46 GMT</pubDate>
  </item><item>
    <title>flatting</title>
    <link>https://nitinsharmacs.github.io/notes/tech/numpy/flatting</link>
    <guid>https://nitinsharmacs.github.io/notes/tech/numpy/flatting</guid>
    <description>Flatting np.ravel method is used for flatting arrays. Flatting starts from last dimension. For example, array of shape (2, 3, 4) will start with dimension 4 then move to next last and so on.</description>
    <pubDate>Wed, 18 Sep 2024 14:29:26 GMT</pubDate>
  </item><item>
    <title>comparisons</title>
    <link>https://nitinsharmacs.github.io/notes/tech/numpy/comparisons</link>
    <guid>https://nitinsharmacs.github.io/notes/tech/numpy/comparisons</guid>
    <description>Comparisons Comparisons can be elementwise or arraywise. Elementwise comparisons a = np.arange(5) b = np.array([5, 1, 9, 6, 4]) a &lt; b # array([ True, False, True, True, False]) a == b # array([False, True, False, False, True]) Arraywise comparisons Comparisons on the arrays instead of individual elements.</description>
    <pubDate>Wed, 18 Sep 2024 07:10:20 GMT</pubDate>
  </item><item>
    <title>fancy-indexing</title>
    <link>https://nitinsharmacs.github.io/notes/tech/numpy/fancy-indexing</link>
    <guid>https://nitinsharmacs.github.io/notes/tech/numpy/fancy-indexing</guid>
    <description>Fancy Indexing Arrays created using fancy indexing such as boolean masks or integer arrays, are copies of the original array, not the views. Using Masks a = np.arange(10) sub_array = a[a%2 == 0] # array([0, 2, 4, 6, 8]) sub_array doesnâ€™t share the same memory buffer with array a.</description>
    <pubDate>Tue, 17 Sep 2024 14:12:43 GMT</pubDate>
  </item><item>
    <title>slicing</title>
    <link>https://nitinsharmacs.github.io/notes/tech/numpy/slicing</link>
    <guid>https://nitinsharmacs.github.io/notes/tech/numpy/slicing</guid>
    <description>Slicing Slicing consists three components, start:end:step. By default, start is 1, end is last and step is 1. a = np.arange(10) a[1:] # array([1, 2, 3, 4, 5, 6, 7, 8, 9]) a[:3] # array([0, 1, 2]), last index is not included.</description>
    <pubDate>Tue, 17 Sep 2024 13:16:19 GMT</pubDate>
  </item><item>
    <title>datatypes</title>
    <link>https://nitinsharmacs.github.io/notes/tech/numpy/datatypes</link>
    <guid>https://nitinsharmacs.github.io/notes/tech/numpy/datatypes</guid>
    <description>Datatypes Following are the available datatypes in numpy. int32, int64, uint32, uint64 float64 (default) complex128 bool strings are typed by taking the maximum length string in the array.</description>
    <pubDate>Tue, 17 Sep 2024 12:53:13 GMT</pubDate>
  </item><item>
    <title>index</title>
    <link>https://nitinsharmacs.github.io/</link>
    <guid>https://nitinsharmacs.github.io/</guid>
    <description>bitPhile A knowledge repository where I add my daily notes on tech I read and blogs I create, and other content.</description>
    <pubDate>Thu, 12 Sep 2024 06:27:11 GMT</pubDate>
  </item><item>
    <title>map_blocks</title>
    <link>https://nitinsharmacs.github.io/notes/tech/xarray/map_blocks</link>
    <guid>https://nitinsharmacs.github.io/notes/tech/xarray/map_blocks</guid>
    <description>xarray.map_blocks It applies custom function on each chunk block of the DataArray or Dataset. def add_wrapper(d): print(&#039;------------------- START ---------------------&#039;) print(type(d)) print(d.shape) print(d) print(&#039;-------------------- END ------------------------&#039;) return d + 1 xda = ds.air[:2, :5, :5].chunk({&quot;time&quot;: 1}) xr.map_blocks(add_wrapper, ds.air).compute() Output ------------------- START --------------------- &lt;class &#039;xarray.core.dataarray.DataArray&#039;&gt; (0, 0, 0) &lt;xarray.DataArray &#039;air&#039; (time: 0, lat: 0, lon: 0)&gt; Size: 0B array([], shape=(0, 0, 0), dtype=float64) -------------------- END ------------------------ ------------------- START --------------------- &lt;class &#039;xarray.core.dataarray.DataArray&#039;&gt; (1, 5, 5) &lt;xarray.DataArray &#039;air&#039; (time: 1, lat: 5, lon: 5)&gt; Size: 200B array([[[241.2 , 242.5 , 243.5 , 244.</description>
    <pubDate>Wed, 11 Sep 2024 14:20:18 GMT</pubDate>
  </item><item>
    <title>docker-storage-driver</title>
    <link>https://nitinsharmacs.github.io/blogs/tech/docker/docker-storage-driver</link>
    <guid>https://nitinsharmacs.github.io/blogs/tech/docker/docker-storage-driver</guid>
    <description></description>
    <pubDate>Tue, 10 Sep 2024 12:41:01 GMT</pubDate>
  </item>
    </channel>
  </rss>