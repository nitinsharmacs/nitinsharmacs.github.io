<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
    <channel>
      <title>bitPhile</title>
      <link>https://nitinsharmacs.github.io</link>
      <description>Last 10 notes on bitPhile</description>
      <generator>Quartz -- quartz.jzhao.xyz</generator>
      <item>
    <title>interoperability</title>
    <link>https://nitinsharmacs.github.io/notes/tech/numpy/interoperability</link>
    <guid>https://nitinsharmacs.github.io/notes/tech/numpy/interoperability</guid>
    <description>Interoperability Interoperability defines how well numpy integrates with other libraries. To accomplish this, there are solutions like old buffer protocol and array interface.</description>
    <pubDate>Mon, 30 Sep 2024 17:44:37 GMT</pubDate>
  </item><item>
    <title>export</title>
    <link>https://nitinsharmacs.github.io/notes/tech/conda/export</link>
    <guid>https://nitinsharmacs.github.io/notes/tech/conda/export</guid>
    <description>Conda export Exporting all the dependencies and their additional packages. conda env export &gt; file.yml # or conda export -n env &gt; file.yml This make sense when environment is being created in same platform as the source.</description>
    <pubDate>Sun, 29 Sep 2024 07:40:41 GMT</pubDate>
  </item><item>
    <title>strides</title>
    <link>https://nitinsharmacs.github.io/notes/tech/numpy/strides</link>
    <guid>https://nitinsharmacs.github.io/notes/tech/numpy/strides</guid>
    <description>Strides array.strides gives the number of bytes need to be jumped to find the next elements on the corresponding dimensions. a = np.arange(4).reshape((2, 2)) # array([[0, 1], # [2, 3]]) a.strides # (16, 8) So, 16 bytes for x-axis and 8 bytes for y-axis needs to be jumped to get to next element.</description>
    <pubDate>Fri, 27 Sep 2024 09:04:45 GMT</pubDate>
  </item><item>
    <title>setup-ssh-with-gitlab</title>
    <link>https://nitinsharmacs.github.io/notes/tech/git/setup-ssh-with-gitlab</link>
    <guid>https://nitinsharmacs.github.io/notes/tech/git/setup-ssh-with-gitlab</guid>
    <description>Setup ssh with gitlab Step 1: Generate ssh key pair ssh-keygen -t rsa -b 2048 -C &quot;nitinsharmacs@gitlab.com&quot; -t can be any encryption you want to use ...</description>
    <pubDate>Fri, 27 Sep 2024 06:28:42 GMT</pubDate>
  </item><item>
    <title>gitlab-ci</title>
    <link>https://nitinsharmacs.github.io/notes/tech/git/gitlab-ci</link>
    <guid>https://nitinsharmacs.github.io/notes/tech/git/gitlab-ci</guid>
    <description>Gitlab CI A gitlab ci contains stages and job. Jobs are grouped in stages and run in parallel. stages: - build - deploy build-job: stage: build image: node script: - npm install - npm run build artifacts: paths: - &quot;build/&quot; pages: stage: deploy script: - mv build/ public/ artifacts: paths: - &quot;public/&quot; stages directive defines the sequence of jobs.</description>
    <pubDate>Fri, 27 Sep 2024 06:28:42 GMT</pubDate>
  </item><item>
    <title>apply_ufunc-dask</title>
    <link>https://nitinsharmacs.github.io/notes/tech/xarray/apply_ufunc-dask</link>
    <guid>https://nitinsharmacs.github.io/notes/tech/xarray/apply_ufunc-dask</guid>
    <description>apply_ufunc with dask arrays apply_ufunc handles dask xarray in same manner as it does with numpy xarray. However, it requires an dask argument` to work with dask xarrays.</description>
    <pubDate>Fri, 27 Sep 2024 06:28:42 GMT</pubDate>
  </item><item>
    <title>map_blocks</title>
    <link>https://nitinsharmacs.github.io/notes/tech/xarray/map_blocks</link>
    <guid>https://nitinsharmacs.github.io/notes/tech/xarray/map_blocks</guid>
    <description>xarray.map_blocks It applies custom function on each chunk block of the DataArray or Dataset. def add_wrapper(d): print(&#039;------------------- START ---------------------&#039;) print(type(d)) print(d.shape) print(d) print(&#039;-------------------- END ------------------------&#039;) return d + 1 xda = ds.air[:2, :5, :5].chunk({&quot;time&quot;: 1}) xr.map_blocks(add_wrapper, ds.air).compute() Output ------------------- START --------------------- &lt;class &#039;xarray.core.dataarray.DataArray&#039;&gt; (0, 0, 0) &lt;xarray.DataArray &#039;air&#039; (time: 0, lat: 0, lon: 0)&gt; Size: 0B array([], shape=(0, 0, 0), dtype=float64) -------------------- END ------------------------ ------------------- START --------------------- &lt;class &#039;xarray.core.dataarray.DataArray&#039;&gt; (1, 5, 5) &lt;xarray.DataArray &#039;air&#039; (time: 1, lat: 5, lon: 5)&gt; Size: 200B array([[[241.2 , 242.5 , 243.5 , 244.</description>
    <pubDate>Fri, 27 Sep 2024 06:28:42 GMT</pubDate>
  </item><item>
    <title>apply_ufunc</title>
    <link>https://nitinsharmacs.github.io/notes/tech/xarray/apply_ufunc</link>
    <guid>https://nitinsharmacs.github.io/notes/tech/xarray/apply_ufunc</guid>
    <description>apply_ufunc Xarray method that applies custom function on underlying array in xarray. The underlying array can be a numpy or a dask array (need verification).</description>
    <pubDate>Fri, 27 Sep 2024 06:28:42 GMT</pubDate>
  </item><item>
    <title>loop-dimensions</title>
    <link>https://nitinsharmacs.github.io/notes/tech/xarray/loop-dimensions</link>
    <guid>https://nitinsharmacs.github.io/notes/tech/xarray/loop-dimensions</guid>
    <description>Loop Dimensions Functions that performs operations on data with core-dimensions and taking axis as argument, can be easily used with apply_ufunc. However, functions which donâ€™t take axis argument and need to work on core-dimensions need loop dimensions.</description>
    <pubDate>Fri, 27 Sep 2024 06:28:42 GMT</pubDate>
  </item><item>
    <title>xarray-with-dask</title>
    <link>https://nitinsharmacs.github.io/notes/tech/xarray/xarray-with-dask</link>
    <guid>https://nitinsharmacs.github.io/notes/tech/xarray/xarray-with-dask</guid>
    <description>Xarray with Dask Xarray is numpy array with metadata and accessing the array with metadata. Xarray does the computations in memory so has the limitation on data size.</description>
    <pubDate>Fri, 27 Sep 2024 06:28:42 GMT</pubDate>
  </item>
    </channel>
  </rss>