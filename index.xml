<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
    <channel>
      <title>bitPhile</title>
      <link>https://nitinsharmacs.github.io</link>
      <description>Last 10 notes on bitPhile</description>
      <generator>Quartz -- quartz.jzhao.xyz</generator>
      <item>
    <title>ogrid</title>
    <link>https://nitinsharmacs.github.io/notes/tech/numpy/ogrid</link>
    <guid>https://nitinsharmacs.github.io/notes/tech/numpy/ogrid</guid>
    <description>np.ogrid The way it is different than np.mgrid is that it does not include all the elements required for the grid. It returns 1D arrays and rest of the things lie on the numpy broadcasting.</description>
    <pubDate>Mon, 07 Oct 2024 16:28:00 GMT</pubDate>
  </item><item>
    <title>grids-in-numpy</title>
    <link>https://nitinsharmacs.github.io/notes/tech/numpy/notebook/grids-in-numpy</link>
    <guid>https://nitinsharmacs.github.io/notes/tech/numpy/notebook/grids-in-numpy</guid>
    <description>Grids in numpy import numpy as np import matplotlib.pyplot as plt %matplotlib inline a = np.array([3, 1, 2, 5, 6, 7]) b = np.array(a[::-1]) x, y = np.meshgrid(a, b) x, y (array([[3, ...</description>
    <pubDate>Fri, 04 Oct 2024 12:44:27 GMT</pubDate>
  </item><item>
    <title>mgrid</title>
    <link>https://nitinsharmacs.github.io/notes/tech/numpy/mgrid</link>
    <guid>https://nitinsharmacs.github.io/notes/tech/numpy/mgrid</guid>
    <description>numpy.mgrid numpy.mgridcan be used to create meshgrid by using slices. np.mgrid[0:5, 0:5] array([[[0, 0, 0, 0, 0], [1, 1, 1, 1, 1], [2, 2, 2, 2, 2], [3, 3, 3, 3, 3], [4, 4, 4, 4, 4]], [[0, 1, 2, 3, 4], [0, 1, 2, 3, 4], [0, 1, 2, 3, 4], [0, 1, 2, 3, 4], [0, 1, 2, 3, 4]]]) This is equivalent to, np.meshgrid(np.arange(5), np.arange(5), indexing=&quot;ij&quot;) [array([[0, 0, 0, 0, 0], [1, 1, 1, 1, 1], [2, 2, 2, 2, 2], [3, 3, 3, 3, 3], [4, 4, 4, 4, 4]]), array([[0, 1, 2, 3, 4], [0, 1, 2, 3, 4], [0, 1, 2, 3, 4], [0, 1, 2, 3, 4], [0, 1, 2, 3, 4]])] np.mgrid uses matrix indexing system.</description>
    <pubDate>Fri, 04 Oct 2024 11:42:00 GMT</pubDate>
  </item><item>
    <title>dump</title>
    <link>https://nitinsharmacs.github.io/notes/tech/matplotlib/dump</link>
    <guid>https://nitinsharmacs.github.io/notes/tech/matplotlib/dump</guid>
    <description>plt.imshow( output, cmap=&quot;gray&quot;, extent=[np.min(x), np.max(x), np.min(y), np.max(y)] ).</description>
    <pubDate>Fri, 04 Oct 2024 11:17:00 GMT</pubDate>
  </item><item>
    <title>meshgrid</title>
    <link>https://nitinsharmacs.github.io/notes/tech/numpy/meshgrid</link>
    <guid>https://nitinsharmacs.github.io/notes/tech/numpy/meshgrid</guid>
    <description>Meshgrid Numpy meshgrid creates grid matrices from the input arrays. These matrices are also called coordinate matrices. figure: From microsoft excel. Showing good example of meshgrid.</description>
    <pubDate>Fri, 04 Oct 2024 05:20:00 GMT</pubDate>
  </item><item>
    <title>polyfit</title>
    <link>https://nitinsharmacs.github.io/notes/tech/numpy/notebook/polyfit</link>
    <guid>https://nitinsharmacs.github.io/notes/tech/numpy/notebook/polyfit</guid>
    <description>import numpy as np import matplotlib.pyplot as plt polyfit Objective is to create a fit of a set of data points and plot it. 1 degree polynomial x = np.array([1, 2, 3, 4]) y = np.array([1, 2, 3, 4]) fit = np.polyfit(x, y, 1) equation = np.poly1d(fit) x_points = np.linspace(1, 10, 100) y_points = equation(x_points) plt.figure(figsize=(4, 2)) plt.plot(x, y, &#039;.&#039;) plt.plot(x_points, y_points, &#039;-r&#039;) [&lt;matplotlib.lines.Line2D at 0x14c8564d0&gt;] 2 degree polynomial degree_2_fit = np.polyfit(x, y, 2) degree_2_eq = np.poly1d(degree_2_fit) print(degree_2_eq) 2 -4.958e-16 x + 1 x - 2.442e-15 y_points = degree_2_eq(x_points) plt.figure(figsize=(4, 2)) plt.plot(x, y, &#039;.&#039;, x_points, y_points, &#039;-r&#039;) [&lt;matplotlib.lines.Line2D at 0x14c7af670&gt;, &lt;matplotlib.lines.Line2D at 0x14c7afcd0&gt;] .</description>
    <pubDate>Thu, 03 Oct 2024 12:40:38 GMT</pubDate>
  </item><item>
    <title>numpy.polynomials</title>
    <link>https://nitinsharmacs.github.io/notes/tech/numpy/notebook/numpy.polynomials</link>
    <guid>https://nitinsharmacs.github.io/notes/tech/numpy/notebook/numpy.polynomials</guid>
    <description>Goal Understanding polynomials handling methods of numpy. Includes poly1d polyval polyfit import numpy as np poly1d Creates a polynomial Creating polynomial # Creating polynomial of order 1 # 2x + 1 pol = np.poly1d([2, 1]) print(pol) 2 x + 1 # Creating a polynomal of order 2 # 2x^2 + 3x + 4 pol = np.poly1d([2, 3, 4]) print(pol) 2 2 x + 3 x + 4 Evaluation # Evaluating pol with x = 2 print(pol) print(pol(2)) print(pol([2, 3, 4])) 2 2 x + 3 x + 4 18 [18 31 48] Arithmetic operations # addition of pols print(pol + pol) # multiplication print(pol * pol) # division print(pol / pol) # returns quotient and remainder # square pols print(pol ** 3) 2 4 x + 6 x + 8 4 3 2 4 x + 12 x + 25 x + 24 x + 16 (poly1d([1.]), poly1d([0.])) 6 5 4 3 2 8 x + 36 x + 102 x + 171 x + 204 x + 144 x + 64 polyval np.polynomial.polynomial.polyval([1,2,3, 4], [2, 3, 4]) array([ 9., 24., 47., 78.]) print(pol(4)) 48 Issue? print(pol) print(pol(2)) print(np.polynomial.polynomial.polyval(2, pol)) # why both evaluations result different values? 2 2 x + 3 x + 4 18 24.0 polyfit polyfit is used to find the cofficient of a polynomial that best fits the given data points.</description>
    <pubDate>Thu, 03 Oct 2024 12:40:38 GMT</pubDate>
  </item><item>
    <title>interoperability</title>
    <link>https://nitinsharmacs.github.io/notes/tech/numpy/interoperability</link>
    <guid>https://nitinsharmacs.github.io/notes/tech/numpy/interoperability</guid>
    <description>Interoperability Interoperability defines how well numpy integrates with other libraries. To accomplish this, there are solutions like old buffer protocol and array interface.</description>
    <pubDate>Mon, 30 Sep 2024 17:44:00 GMT</pubDate>
  </item><item>
    <title>export</title>
    <link>https://nitinsharmacs.github.io/notes/tech/conda/export</link>
    <guid>https://nitinsharmacs.github.io/notes/tech/conda/export</guid>
    <description>Conda export Exporting all the dependencies and their additional packages. conda env export &gt; file.yml # or conda export -n env &gt; file.yml This make sense when environment is being created in same platform as the source.</description>
    <pubDate>Sun, 29 Sep 2024 07:40:00 GMT</pubDate>
  </item><item>
    <title>strides</title>
    <link>https://nitinsharmacs.github.io/notes/tech/numpy/strides</link>
    <guid>https://nitinsharmacs.github.io/notes/tech/numpy/strides</guid>
    <description>Strides array.strides gives the number of bytes need to be jumped to find the next elements on the corresponding dimensions. a = np.arange(4).reshape((2, 2)) # array([[0, 1], # [2, 3]]) a.strides # (16, 8) So, 16 bytes for x-axis and 8 bytes for y-axis needs to be jumped to get to next element.</description>
    <pubDate>Fri, 27 Sep 2024 09:04:00 GMT</pubDate>
  </item>
    </channel>
  </rss>